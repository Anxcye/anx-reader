import "../../Fastfile"

default_platform(:ios)


platform :ios do
  # Authenticate with Apple Store
  private_lane :authenticate_apple_store do
    app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_KEY_P8_BASE64"],
      is_key_content_base64: true,
      in_house: false
    )

  end

  # Build iOS app
  lane :build_ipa do
    verify_env(envs: [
      "ASC_KEY_ID",
      "ASC_ISSUER_ID",
      "ASC_KEY_P8_BASE64",
      "APP_BUNDLE_ID",
      "MATCH_PASSWORD",
      "MATCH_GIT_BASIC_AUTHORIZATION",
    ])

    authenticate_apple_store

    # Sync certificates and profiles using match
    UI.message("Syncing certificates and profiles")


    # get_certificates
    # get_provisioning_profile(app_identifier: "com.anxcye.anxReader")
    # get_provisioning_profile(app_identifier: "com.anxcye.anxReader.shareExtension")
  
    sync_code_signing(
      type: "appstore",
      readonly: is_ci,
    )
    commit = last_git_commit
    puts "*** Starting iOS release for commit(#{commit[:abbreviated_commit_hash]}) ***"
    
    sh_on_root(command: "which pod && which ruby")

      # 在 CI 中添加更多调试信息
  if is_ci
    UI.message("CI Debug: Checking keychain status...")
    sh_on_root(command: "security list-keychains")
    sh_on_root(command: "security default-keychain")
    
    UI.message("CI Debug: Checking provisioning profiles...")
    sh_on_root(command: "ls -la ~/Library/MobileDevice/Provisioning\\ Profiles/ || echo 'Provisioning profiles directory not found'")
    
    UI.message("CI Debug: Checking certificates in keychain...")
    sh_on_root(command: "security find-certificate -a -p | grep 'BEGIN CERTIFICATE' | wc -l")
  end

    # Verify certificates are available
    UI.message("Checking available certificates...")
    sh_on_root(command: "security find-identity -v -p codesigning")

    fetch_dependencies
    sh_on_root(command: "flutter build ipa --release --dart-define=isAppStore=true --no-codesign")
  end


  desc "Release a new build to Apple Store"
  lane :release_app_store do |options|


    build_ipa

  begin
    build_app(
      skip_build_archive: false,
      archive_path: "../build/ios/archive/Runner.xcarchive",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "com.anxcye.anxReader" => "match AppStore com.anxcye.anxReader",
          "com.anxcye.anxReader.shareExtension" => "match AppStore com.anxcye.anxReader.shareExtension"
        },
        signingStyle: "manual",
        stripSwiftSymbols: true,
        compileBitcode: false, # 禁用 Bitcode 可能解决卡顿问题
        uploadBitcode: false,
        uploadSymbols: false
      },
      export_timeout: 600, # 增加到10分钟超时
      silent: false, # 确保输出详细信息
      suppress_xcode_output: false # 不抑制 Xcode 输出
    )
  rescue => ex
    UI.error("build_app failed: #{ex.message}")
    
    # 输出更多调试信息
    UI.message("Archive contents:")
    sh_on_root(command: "ls -la ../build/ios/archive/ || echo 'Archive directory not found'")
    
    UI.message("Build directory contents:")
    sh_on_root(command: "ls -la ../build/ios/ || echo 'Build directory not found'")
    
    raise ex
  end

    upload_to_testflight(
      skip_waiting_for_build_processing: true
    )
  end
  
  # This is a work in progress, requiring ad-hoc export method
  # desc "Release to Play Store using Firebase App Distribution"
  # lane :release_to_firebase do |options|
  #   begin
  #     build_ipa

  #     firebase_app_distribution(
  #       app: ENV["FIREBASE_APP_ID"],
  #       service_credentials_file: google_service_account_json_path,
  #       ipa_path: "../build/ios/Runner.ipa"
  #     )
  #   end
  # end
end
